[![Review Assignment Due Date](https://classroom.github.com/assets/deadline-readme-button-24ddc0f5d75046c5622901739e7c5dd533143b0c8e959d652212380cedb1ea36.svg)](https://classroom.github.com/a/-ucQIGTc)
[![Open in Visual Studio Code](https://classroom.github.com/assets/open-in-vscode-718a45dd9cf7e7f842a935f5ebbe5719a5e09af4491e668f4dbf3b35d5cca122.svg)](https://classroom.github.com/online_ide?assignment_repo_id=15227220&assignment_repo_type=AssignmentRepo)
# SE-Assignment-2
Assignment: Introduction to Software Engineering 
Instructions:
Answer the following questions based on your understanding of software engineering concepts. Provide detailed explanations and examples where appropr

Questions:
Define Software Engineering: 

 Software engineering is the systematic application of engineering principles and practices to the design, development, testing, and maintenance of software systems. It involves the use of various tools, techniques, and methodologies to create high-quality, reliable, and efficient software that meets the needs of users and organizations.



What is software engineering, and how does it differ from traditional programming? 

  software engineering provides a comprehensive framework for developing software systematically and reliably, whereas traditional programming focuses more narrowly on the coding aspect. The SDLC offers a structured approach to manage the complexities of software development, ensuring that projects meet user needs and quality standards.


Software Engineering:

 Software engineering is a structured approach to designing, developing, testing, and maintaining software applications by applying engineering principles.

Scope: It encompasses the entire software development life cycle (SDLC), including requirements gathering, system design, coding, testing, deployment, and maintenance.

Methodologies: Utilizes various methodologies and frameworks (e.g., Agile, Waterfall, Scrum) to manage the development process.
Focus: Emphasizes creating software that is reliable, maintainable, scalable, and meets the specific needs of users and stakeholders.
Interdisciplinary Approach: Integrates concepts from computer science, project management, quality assurance, and more.


Traditional Programming:

Traditional programming primarily involves writing code to implement specific functionalities or solve particular problems.
Scope: Focuses on the coding phase of software development, often with less emphasis on formal methodologies, documentation, and long-term maintenance.

Process: May not follow a structured process; programmers might work individually or in small teams, often with ad-hoc methods.
Focus: Concentrates on solving immediate problems or implementing features without necessarily considering the broader software development lifecycle.

Key Differences:

Process and Methodology:

Software Engineering: Follows structured methodologies, standards, and best practices throughout the SDLC.

Traditional Programming: Focuses on the coding aspect with less emphasis on formal processes and methodologies.

Scope and Scale:

Software Engineering: Deals with large-scale projects, often involving multiple teams and stakeholders.

Traditional Programming: Typically involves smaller, more isolated tasks or projects.

Maintenance and Evolution:

Software Engineering: Emphasizes long-term maintenance, scalability, and adaptability of the software.

Traditional Programming: Maintenance and evolution may not be primary concerns.

Interdisciplinary Nature: Software Engineering: Involves collaboration among various roles like analysts, designers, testers, and project managers.

Traditional Programming:  Primarily involves programmers or developers with limited interdisciplinary collaboration.


Software Development Life Cycle (SDLC):  The Software Development Life Cycle is a key aspect of software engineering. It involves a series of stages that software developers follow to ensure that software is developed in a structured and controlled manner.

Explain the various phases of the Software Development Life Cycle.Provide a brief description of each phase.
Agile vs. Waterfall Models:


*Requirements: Gather and Identifying the needs and requirements of the software.
*Design: Creating a detailed plan for the software, including its architecture, modules, and interfaces.
*Implementation: Writing code and developing the software.
*Testing: Verifying that the software meets the specified requirements and identifying and fixing any defects or bugs.
*Deployment: Releasing the software to the end-users and ensuring that it operates correctly in the production environment.
*Maintenance: Updating and improving the software over time to address changing requirements, fix issues, and enhance performance.

The Agile model is an iterative and incremental approach that emphasizes collaboration, flexibility, and rapid delivery. It is characterized by:
*Short development cycles (sprints)
*Frequent releases and feedback
*Adaptability to changing requirements
*Close collaboration between the development team and stakeholders

The Waterfall model, on the other hand, is a sequential approach where each phase is completed before moving on to the next. It is characterized by:
*A linear and rigid process
*Well-defined phases with clear deliverables
*Limited flexibility to accommodate changes
The choice between the Agile and Waterfall models depends on factors such as project size, complexity, team structure, and the ability to accommodate changes. Agile is often preferred for projects with evolving requirements and tight timelines, while Waterfall is suitable for projects with well-defined and stable requirements.
 


Compare and contrast the Agile and Waterfall models of software development. What are the key differences, and in what scenarios might each be preferred?
Requirements Engineering:

The Agile and Waterfall models are two popular approaches to software development. While both models have their strengths and weaknesses, they differ significantly in their philosophies, methodologies, and outcomes.
Agile Model

The Agile model is an iterative and incremental approach to software development. It emphasizes collaboration, flexibility, and rapid delivery. Key characteristics of the Agile model include:
Iterative Development: Agile development involves breaking down the project into smaller, manageable chunks, and then iteratively refining and improving each chunk.

Collaboration: Agile emphasizes close collaboration between the development team, stakeholders, and customers to ensure that the software meets the needs and expectations of all parties.

Flexibility: Agile allows for flexibility in the development process, enabling the team to adapt to changing requirements and priorities.
Rapid Delivery: Agile focuses on delivering working software in short cycles, typically every 2-4 weeks, to ensure that the software is functional and meets the needs of the stakeholders.

Continuous Improvement: Agile encourages continuous improvement through retrospectives, feedback, and iterative refinement.

Waterfall Model

The Waterfall model is a linear and sequential approach to software development. It emphasizes predictability, control, and a clear plan. Key characteristics of the Waterfall model include:

Sequential Development: Waterfall development involves breaking down the project into distinct phases, with each phase completed before moving on to the next.

Predictability: Waterfall emphasizes predictability, with a clear plan and timeline for each phase.
Control: Waterfall provides a high level of control over the development process, with each phase carefully planned and executed.

Fixed Timeline: Waterfall typically involves a fixed timeline, with each phase completed within a specific timeframe.

Less Flexibility: Waterfall is less flexible than Agile, as changes to the plan or requirements can be difficult and costly to implement.
Key Differences

The key differences between Agile and Waterfall models are:

Approach: Agile is iterative and incremental, while Waterfall is linear and sequential.

Flexibility: Agile is more flexible, allowing for changes and adaptations during the development process. Waterfall is less flexible, with changes often requiring significant rework.

Collaboration: Agile emphasizes collaboration between the development team, stakeholders, and customers. Waterfall tends to focus on a single, centralized plan.

Delivery: Agile focuses on delivering working software in short cycles, while Waterfall typically involves a single, large release.

Risk Management: Agile is better suited for managing risk, as it allows for rapid adaptation to changing requirements and priorities. Waterfall can be more prone to risk, as changes can be difficult and costly to implement.

Scenarios for Each Model

Each model has its own strengths and weaknesses, and the choice between Agile and Waterfall depends on the specific project requirements and constraints. Here are some scenarios where each model might be preferred:

Agile:

Projects with evolving requirements or changing priorities.
Projects that require rapid delivery and adaptability.
Projects with a high level of uncertainty or risk.
Projects that involve multiple stakeholders with diverse needs and expectations.

Waterfall:

Projects with well-defined requirements and a clear plan.
Projects that require a high level of predictability and control.
Projects with a fixed timeline and budget.
Projects that involve a single, centralized plan and a clear hierarchy.
Requirements Engineering
Requirements engineering is a critical aspect of software development, as it involves defining and managing the requirements of the software. Both Agile and Waterfall models involve requirements engineering, but they approach it differently:

Agile:

Agile emphasizes collaboration and iterative refinement of requirements.
Agile involves continuous feedback and adaptation to changing requirements.
Agile focuses on delivering working software that meets the needs of the stakeholders.
Waterfall:
Waterfall involves a more formal and structured approach to requirements engineering.
Waterfall emphasizes a clear plan and timeline for requirements gathering and analysis.
Waterfall focuses on delivering a single, large release that meets the requirements.

What is requirements engineering? Describe the process and its importance in the software development lifecycle. Software Design Principles:

Requirements engineering is the process of defining and managing the requirements of a software system. It involves identifying, analyzing, documenting, and validating the needs and expectations of the stakeholders to ensure that the software meets their needs and expectations.

Process of Requirements Engineering

The process of requirements engineering typically involves the following steps:
Requirements Gathering: Identifying the needs and expectations of the stakeholders through interviews, surveys, and other methods.
Requirements Analysis: Analyzing the gathered requirements to identify the functional and non-functional requirements, and to ensure that they are clear, concise, and unambiguous.

Requirements Documentation: Documenting the requirements in a clear and concise manner, using techniques such as use cases, user stories, and functional specifications.

Requirements Validation: Validating the requirements to ensure that they are accurate, complete, and consistent with the stakeholders' needs and expectations.

Requirements Management: Managing the requirements throughout the software development lifecycle, ensuring that they are updated and refined as necessary.

Importance of Requirements Engineering

Requirements engineering is crucial in the software development lifecycle because it ensures that the software meets the needs and expectations of the stakeholders. It helps to:

Ensure that the software meets the stakeholders' needs: By identifying and analyzing the requirements, the software development team can ensure that the software meets the stakeholders' needs and expectations.

Reduce the risk of errors and defects: By ensuring that the requirements are clear, concise, and unambiguous, the risk of errors and defects is reduced.

Improve the quality of the software: By ensuring that the requirements are accurate, complete, and consistent, the quality of the software is improved.

Enhance the user experience: By ensuring that the requirements are user-centered, the user experience is enhanced, and the software is more usable and accessible.

Software Design Principles

Software design principles are guidelines that help software developers to design software that is robust, maintainable, and scalable. Some key software design principles include:

Separation of Concerns: Separating the software into distinct components or layers, each with its own specific responsibilities.

Single Responsibility Principle: Ensuring that each component or layer has a single responsibility or function.

Open-Closed Principle: Ensuring that the software is open to extension but closed to modification.

Liskov Substitution Principle: Ensuring that the software is designed to be modular and scalable.

Interface Segregation Principle: Ensuring that the software is designed to be modular and scalable.

These principles help to ensure that the software is designed in a way that is robust, maintainable, and scalable, and that it meets the needs and expectations of the stakeholders.


Explain the concept of modularity in software design. How does it improve maintainability and scalability of software systems?
Testing in Software Engineering:

Modularity in software design refers to the practice of breaking down a large software system into smaller, independent modules or components that can be developed, tested, and maintained separately. Each module has a specific function or responsibility and is designed to be self-contained, with minimal dependencies on other modules.

Benefits of Modularity

Modularity offers several benefits, including:

Improved Maintainability: Modular software is easier to maintain because changes can be made to individual modules without affecting the entire system. 

This reduces the risk of introducing bugs or errors.

Increased Scalability: Modular software can be scaled more easily because new modules can be added or removed as needed, without affecting the existing system.

Reduced Complexity: Modular software is less complex because each module has a specific function and is designed to be self-contained. This makes it easier to understand and debug.

Improved Reusability: Modular software can be reused in other projects or applications because each module is designed to be independent and can be easily integrated into other systems.

How Modularity Improves Maintainability and Scalability

Modularity improves maintainability and scalability in several ways:

Easier Debugging: With modular software, it is easier to identify and debug issues because each module has a specific function and can be tested independently.

Faster Development: Modular software allows developers to work on individual modules simultaneously, reducing the overall development time.
Improved Flexibility: Modular software is more flexible because new modules can be added or removed as needed, allowing for greater adaptability to changing requirements.

Reduced Risk: Modular software reduces the risk of introducing bugs or errors because changes can be made to individual modules without affecting the entire system.

Testing in Software Engineering

Testing is a critical aspect of software engineering that involves verifying that the software meets the specified requirements and works as expected. 

There are several types of testing, including:

Unit Testing: Testing individual modules or components to ensure they work correctly.

Integration Testing: Testing how different modules or components interact with each other.

System Testing: Testing the entire software system to ensure it meets the specified requirements.

Acceptance Testing: Testing the software to ensure it meets the user's expectations and requirements.


Importance of Testing

Testing is important because it helps to:

Identify Defects: Testing helps to identify defects or bugs in the software, which can be fixed before the software is released.

Improve Quality: Testing helps to improve the quality of the software by ensuring it meets the specified requirements and works as expected.

Reduce Risk: Testing helps to reduce the risk of introducing bugs or errors into the software, which can cause problems for users.

Increase Confidence: Testing helps to increase confidence in the software by ensuring it works correctly and meets the user's expectations.

Conclusion
Modularity is a key concept in software design that improves maintainability and scalability by breaking down a large software system into smaller, independent modules. Each module has a specific function or responsibility and is designed to be self-contained, with minimal dependencies on other modules. Testing is also a critical aspect of software engineering that helps to identify defects, improve quality, reduce risk, and increase confidence in the software.




Describe the different levels of software testing (unit testing, integration testing, system testing, acceptance testing). Why is testing crucial in software development?
Version Control Systems:


Software testing is a crucial aspect of software development that involves verifying that the software meets the specified requirements and works as expected. 
There are several levels of software testing, each with its own specific goals and objectives:

Unit Testing: Unit testing involves testing individual components or modules of the software to ensure they work correctly. 
This level of testing is typically performed by the development team and is used to ensure that each component meets the specified requirements.

Integration Testing: Integration testing involves testing how different components or modules of the software interact with each other. 
This level of testing is used to ensure that the software works correctly when different components are combined.

System Testing: System testing involves testing the entire software system to ensure it meets the specified requirements and works as expected. This level of testing is used to ensure that the software works correctly in a real-world environment.

Acceptance Testing: Acceptance testing involves testing the software to ensure it meets the user's expectations and requirements. This level of testing is used to ensure that the software is acceptable for release to the end-users.

Why Testing is Crucial in Software Development

Testing is crucial in software development for several reasons:
Ensures Software Quality: Testing helps ensure that the software meets the specified requirements and works as expected, which helps to ensure high-quality software.

Identifies Defects: Testing helps identify defects or bugs in the software, which can be fixed before the software is released.

Reduces Risk: Testing helps reduce the risk of introducing bugs or errors into the software, which can cause problems for users.

Improves User Experience: Testing helps improve the user experience by ensuring that the software is easy to use and meets the user's expectations.

Increases Confidence: Testing helps increase confidence in the software by ensuring it works correctly and meets the specified requirements.

Version Control Systems

Version control systems (VCSs) are tools that help manage changes to software code over time. They allow multiple developers to collaborate on a project by tracking changes and maintaining a record of all modifications. Some popular VCSs include:

Git: Git is a popular VCS that is widely used in software development. It allows developers to track changes to code and collaborate on projects.
Subversion (SVN): SVN is another popular VCS that is widely used in software development. It allows developers to track changes to code and collaborate on projects.

Mercurial: Mercurial is a lightweight VCS that is designed for small to medium-sized projects. It allows developers to track changes to code and collaborate on projects.

Perforce: Perforce is a commercial VCS that is widely used in software development. It allows developers to track changes to code and collaborate on projects.

Importance of Version Control Systems

Version control systems are important in software development for several reasons:

Collaboration: VCSs allow multiple developers to collaborate on a project by tracking changes and maintaining a record of all modifications.

Change Management: VCSs help manage changes to software code over time, which helps ensure that the software remains stable and reliable.

Backup and Recovery: VCSs provide a backup of the software code, which helps ensure that the software can be recovered in case of a disaster.

Auditing: VCSs provide an audit trail of all changes made to the software code, which helps ensure that the software is secure and reliable.

Reusability: VCSs help ensure that software code is reusable by tracking changes and maintaining a record of all modifications.


What are version control systems, and why are they important in software development? Give examples of popular version control systems and their features.
Software Project Management:


Version control systems (VCSs) are tools that help manage changes to software code over time. They allow multiple developers to collaborate on a project by tracking changes and maintaining a record of all modifications.

Some popular VCSs include:

Git: Git is a popular VCS that is widely used in software development. It allows developers to track changes to code and collaborate on projects.

Subversion (SVN): SVN is another popular VCS that is widely used in software development. It allows developers to track changes to code and collaborate on projects.

Mercurial: Mercurial is a lightweight VCS that is designed for small to medium-sized projects. It allows developers to track changes to code and collaborate on projects.

Perforce: Perforce is a commercial VCS that is widely used in software development. It allows developers to track changes to code and collaborate on projects.

Version control systems are important in software development for several reasons:

Collaboration: VCSs allow multiple developers to collaborate on a project by tracking changes and maintaining a record of all modifications.

Change Management: VCSs help manage changes to software code over time, which helps ensure that the software remains stable and reliable.

Backup and Recovery: VCSs provide a backup of the software code, which helps ensure that the software can be recovered in case of a disaster.

Auditing: VCSs provide an audit trail of all changes made to the software code, which helps ensure that the software is secure and reliable.

Reusability: VCSs help ensure that software code is reusable by tracking changes and maintaining a record of all modifications.

In conclusion, version control systems are essential tools in software development that help manage changes, enable collaboration, and ensure the reliability and security of software projects.



Discuss the role of a software project manager. What are some key responsibilities and challenges faced in managing software projects?
Software Maintenance:

A software project manager is responsible for overseeing the entire software development process, from planning to delivery. The primary goal of a software project manager is to ensure that the project is completed on time, within budget, and meets the required quality standards.

 Some key responsibilities of a software project manager include:

Project Planning: Defining project scope, goals, timelines, and budget.

Resource Allocation: Assigning tasks to team members and ensuring they have the necessary resources and support.

Risk Management: Identifying and mitigating potential risks and issues that could impact the project.

Communication: Coordinating and communicating with stakeholders, including team members, customers, and sponsors.

Monitoring and Control: Tracking project progress, identifying and addressing issues, and making adjustments as needed.

Quality Assurance: Ensuring that the software meets the required quality standards and that defects are identified and fixed.

Team Management: Leading and managing the development team, including setting goals, providing feedback, and addressing performance issues.

Some common challenges faced by software project managers include:

Scope Creep: Changes to the project scope that can impact timelines and budgets.

Resource Constraints: Limited resources, such as personnel, budget, or equipment, that can impact project progress.

Communication Breakdowns: Poor communication between team members, stakeholders, or customers that can lead to misunderstandings and delays.

Risk Management: Identifying and mitigating potential risks and issues that could impact the project.

Team Management: Managing a diverse team with different skills, experience, and work styles.

Quality Assurance: Ensuring that the software meets the required quality standards and that defects are identified and fixed.

Stakeholder Management: Managing the expectations and needs of various stakeholders, including customers, sponsors, and team members.

S
Software maintenance involves the ongoing process of modifying, testing, and updating software to ensure it continues to meet the needs of users and stakeholders. Some key aspects of software maintenance include:

Bug Fixing: Identifying and fixing defects or bugs in the software.

Performance Optimization: Improving the performance and efficiency of the software.

Feature Enhancements: Adding new features or functionality to the software.

Compatibility Updates: Ensuring the software remains compatible with changing hardware, software, or operating systems.
Security Updates: Addressing security vulnerabilities and ensuring the software remains secure.

Documentation: Maintaining accurate and up-to-date documentation of the software and its components.

Testing: Continuously testing the software to ensure it meets the required quality standards.

In conclusion, a software project manager plays a crucial role in ensuring the successful delivery of software projects. Key responsibilities include project planning, resource allocation, risk management, communication, monitoring and control, quality assurance, and team management. Challenges faced in managing software projects include scope creep, resource constraints, communication breakdowns, risk management, team management, quality assurance, and stakeholder management. Software maintenance involves ongoing modifications, testing, and updates to ensure the software continues to meet user needs.

Define software maintenance and explain the different types of maintenance activities. Why is maintenance an essential part of the software lifecycle?
Ethical Considerations in Software Engineering:

Software maintenance refers to the process of modifying, updating, and improving existing software to ensure it continues to meet the changing needs of users and stakeholders. It involves a series of activities aimed at maintaining the software's quality, reliability, and performance over time.


There are several types of maintenance activities, including:

Corrective Maintenance: Fixing bugs, errors, or defects in the software to ensure it functions correctly.

Adaptive Maintenance: Modifying the software to adapt to changes in the operating environment, such as updates to hardware or software platforms.

Perfective Maintenance: Improving the software's performance, efficiency, or usability to enhance user experience.

Preventive Maintenance: Performing routine maintenance tasks to prevent potential problems or errors from occurring.


Maintenance is an essential part of the software lifecycle because it ensures that the software continues to meet the needs of users and stakeholders.

Some key reasons why maintenance is crucial include:

Ensuring Software Quality: Maintenance helps ensure that the software remains reliable, stable, and secure over time.

Meeting Changing User Needs: Maintenance allows the software to adapt to changing user needs and requirements.

Reducing Costs: Regular maintenance can help reduce costs associated with fixing errors or bugs, as well as minimizing downtime and lost productivity.

Improving User Experience: Maintenance can improve the user experience by enhancing performance, usability, and overall quality of the software.
Ethical Considerations in Software Engineering

Ethical considerations play a vital role in software engineering, as they impact the development and maintenance of software systems.

 Some key ethical considerations include:

Privacy and Security: Ensuring that software systems protect user data and maintain confidentiality.

Intellectual Property: Respecting intellectual property rights and avoiding plagiarism or unauthorized use of code.

Fairness and Bias: Ensuring that software systems are free from bias and treat all users fairly and equally.

Accountability: Taking responsibility for the impact of software systems on users and society as a whole.

In conclusion, software maintenance is a critical aspect of the software lifecycle that ensures the software continues to meet the needs of users and stakeholders. It involves various types of maintenance activities, including corrective, adaptive, perfective, and preventive maintenance. Ethical considerations are also essential in software engineering, as they impact the development and maintenance of software systems.


What are some ethical issues that software engineers might face? How can software engineers ensure they adhere to ethical standards in their work?

Software engineers may face several ethical issues in their work, including:

*Privacy and Data Protection: Ensuring that software systems protect user data and maintain confidentiality.

*Intellectual Property: Respecting intellectual property rights and avoiding plagiarism or unauthorized use of code.

*Fairness and Bias: Ensuring that software systems are free from bias and treat all users fairly and equally.

Accountability: Taking responsibility for the impact of software systems on users and society as a whole.

Security: Ensuring that software systems are secure and protect against potential threats.

Accessibility: Ensuring that software systems are accessible to all users, regardless of their abilities.

Sustainability: Ensuring that software systems are sustainable and do not harm the environment.

Transparency: Ensuring that software systems are transparent and provide clear information to users.

User Consent: Ensuring that users provide informed consent before using software systems.

Professionalism: Maintaining professional standards and ethics in software engineering.
Ensuring Ethical Standards

To ensure adherence to ethical standards, software engineers can:

Follow Industry Guidelines: Adhere to industry guidelines and standards for software engineering, such as the IEEE Code of Ethics.
Conduct Regular Audits: Conduct regular audits to ensure compliance with ethical standards.

Engage in Continuous Learning: Engage in continuous learning and professional development to stay updated on ethical issues and best practices.

Collaborate with Stakeholders: Collaborate with stakeholders, including users and other professionals, to ensure that software systems meet ethical standards.

Report Ethical Concerns: Report any ethical concerns or issues to appropriate authorities or organizations.

Maintain Transparency: Maintain transparency in software development and ensure that users are informed about the software's capabilities and limitations.

Respect User Rights: Respect user rights and ensure that software systems do not infringe on user privacy or intellectual property.

Ensure Accessibility: Ensure that software systems are accessible to all users, regardless of their abilities.

Prioritize Sustainability: Prioritize sustainability in software development and ensure that software systems do not harm the environment.

Maintain Professionalism: Maintain professional standards and ethics in software engineering, including adhering to industry guidelines and best practices.

By following these guidelines, software engineers can ensure that they adhere to ethical standards in their work and maintain the trust of users and stakeholders.



Reference 

Gotterbarn, D., Miller, K. W., & Rogerson, S. (1999). Software Engineering Code of Ethics. Communications of the ACM, 42(10), 102-107.
Pigoski, T. M. (1996). Practical Software Maintenance: Best Practices for Managing Your Software Investment. Wiley.
Hughes, B., & Cotterell, M. (2009). Software Project Management (5th ed.). McGraw-Hill Education.
Myers, G. J., Sandler, C., & Badgett, T. (2011). The Art of Software Testing (3rd ed.). Wiley.
Chacon, S., & Straub, B. (2014). Pro Git (2nd ed.). Apress.
Royce, W. W. (1970). Managing the Development of Large Software Systems. Proceedings of IEEE WESCON.
IEEE Std 12207-2008. Systems and software engineering – Software life cycle processes.
Sommerville, I. (2016). Software Engineering (10th ed.). Pearson.



Your answers should be well-structured, concise, and to the point.
Provide real-world examples or case studies wherever possible.
Cite any references or sources you use in your answers.
Submit your completed assignment by [due date].
